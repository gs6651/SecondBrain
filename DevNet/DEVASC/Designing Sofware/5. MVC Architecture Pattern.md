# MVC Architecture Pattern
The discovery of patterns in software development occurs by arranging components into a single entity. Successful arrangements are documented and reused, with the Model-View-Controller (MVC) pattern being one of the most widely known and used. Originating in the 1970s as part of the Smalltalk object-oriented programming language, the MVC concept evolved into a general principle easily adopted by other programming languages and enforced through various frameworks. MVC remains influential, particularly in user interface frameworks, and is still relevant in interactive desktop and web applications today.
The discovery of patterns in software development occurs by arranging components into a single entity. Successful arrangements are documented and reused, with the Model-View-Controller (MVC) pattern being one of the most widely known and used. Originating in the 1970s as part of the Smalltalk object-oriented programming language, the MVC concept evolved into a general principle easily adopted by other programming languages and enforced through various frameworks. MVC remains influential, particularly in user interface frameworks, and is still relevant in interactive desktop and web applications today.

> **Note:**\
> A framework in programming is a project, providing you with the skeleton code for building an application that can be extended by the programmer to create a specific implementation. It usually comes with already implemented handlers for user authentication, database connection, and similar frequently used actions.

MVC describes the implementation of software components in terms of their responsibilities. The MVC patterns introduce three object roles:
 - Model: This object manages the data and defines business logic of the application.
 - View: This object displays the data to the user, usually through a user interface.
 - Controller: Handles user input, updates the model, and updates the view accordingly.

The three roles in the Model-View-Controller pattern allow for separation of concerns and independent development. Views display information to users while models encapsulate that information. Changes made by users on the view are handled by the controller, which updates the model and informs the view to refresh the presentation.
For example, in a music player application:
 - The Model would hold information such as song title, artist, and playlists.
 - The View would display the song title, artist, play/pause button, and volume control.
 - The Controller would handle the user's actions, such as play/pause, skip, or adjusting the volume.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_001.png)

The three primary benefits of the Model-View-Controller Pattern are: 
 - **Separation of Concerns:** MVC separates the application logic into three distinct components, making the code easier to maintain and understand. The code becomes loosely coupled to each component which is more desired than tightly coupled modules that have inter-dependencies on each other. This also allows for independent testing of components.
 - **Reusability:** By dividing the code into separate components, it becomes easier to reuse the components in other applications. It also makes it easier to add new modules to the application as well.
 - **Improved Flexibility:** The separation of the model, view, and controller components allows for changes to be made to one component without affecting the other components, providing improved flexibility.


The MVC architectural pattern is composed from multiple software design patterns that maintain the relationship between the components and solve problems that MVC introduces by proposing some of its features.
Common design patterns used in MVC:
 - Observer pattern
 - Strategy pattern
 - Composite pattern
 - Factory method
 - Adapter pattern

MVC lets you change how a view responds to user input without having to change or develop another view component. As an example, imagine your application has a registration screen. The view implementing that screen sends the request to the registration controller. The registration controller reads the input and translates it as a request for a model, which stores the request as a new registration. 
Later, you decide you want the registration controller to perform a different set of actions, such as validating the input and attaching additional data to the request before it proceeds to the model. MVC enables you to create a new controller with such features and change the view to use this instead.
Model-View-Controller (MVC) design separates the application's data, business logic, and user interface. The relationship between the view and a controller is an example of the strategy design pattern. This means that the controller is responsible for determining which view should be used to display the requested data. The controller can also decide how the data should be processed and which model to store the data. The view is responsible for the visual representation of the data, while the controller coordinates the interaction between the view and the model.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_003.png)


When your user interface can be combined hierarchically using different elements, such as nested frames and buttons that can be represented as a tree, then you are probably using a structural composite design pattern. The MVC architectural pattern suggests using the composite pattern inside view components. There are other patterns that can be found in MVC, such as factory method, adapter, and decorator, but the main relationships in MVC are constructed using observer, strategy, and composite design patterns.
The benefits of having separated views and models in MVC are obvious, but they also introduce an issue. You can have multiple views that use the same model in your application, so you want to make sure that all active views get updated on a model state change. As seen in one of the previous figures, a change-propagation mechanism is initiated to inform all participants that the state has changed. This mechanism in MVC is typically designed using the observer design pattern, where the view acts as the observer of the model and starts the update procedure when the state changes—that is, when the model notifies the observers.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_004.png)

In this partial UML diagram showing the model component as a class implementation, you can see the required state and method fields. A model stores data of some sort or has at least an option to query it from an underlying storage technology when the view requests it. It also has a list of observers that subscribed to the changes that happen to the model. It implements methods for attaching and detaching new observers, and a method for notifying them on a state change. It must implement methods for responding to data requests coming from the view components.
As the next figure shows, an observable—in this case, the user model—will notify all observers on a state change. If a new observer is required in a form of a view or a controller, it should be easy to attach it to the group of observers. 

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_005.png)

There are many benefits of using the MVC architectural pattern, but there are also some drawbacks that need to be pointed out.
You can benefit from using MVC because it uses separation of concern by introducing component-based development. Each component performs its own specific role. The view component takes care of the presentation side of the application, the model defines the state of the application, and the controller governs the behavior of user actions against the view and the model. Components can then be developed and replaced independently when needed.
The advantage of MVC is that you can prepare multiple views that use the same model, and you can also change the presentation on those views without affecting any of the related components, if the changes are small. The separation of components allows you to test them independently by mocking a component. For example, instead of using a model that works with a complex database system that needs more time to set up, you could mock that database using some other lightweight implementation that would be sufficient for running tests.

Downsides of the MVC pattern:
 - Increased complexity
 - Excessive number of change notifications
 - View and controller tight coupling
 - Separate controller is sometimes not needed

The Model-View-Controller (MVC) pattern can become complicated when handling certain scenarios that don't fit well within the defined structure of MVC. For instance, enabling a form in the view based on the state of the model. The proper way to do this in MVC involves triggering an event, which then goes to the model, and the model informs other observers to retrieve the state. The form is then enabled. However, this can be a complicated process for a simple task, as the MVC model doesn't communicate directly with the view, so it can't make necessary changes to it.

Additionally, a lot of changes being propagated may not be useful for all the views using the observed model. The close relationship between the view and controller can also make it difficult to reuse them separately. Some may argue that the controller separation is not needed, especially when the user interface platform already handles events itself.

## Implementing MVC
Now that you understand the basics of the Model-View-Controller (MVC) pattern, it's time to put that knowledge into practice. In this exercise, you will learn how to construct a basic MVC structure using Python. As previously mentioned, there are three main components - model, view, and controller - that you will implement and connect together. It is important to make sure that these components are not tightly coupled. The view should be separate from the model, and any changes made in the view should not impact other views related to the same model. Additionally, the views and controllers should be easily interchangeable, even during the program's execution..

Before coding, it's recommended to design your program at a higher-level using UML class diagrams to outline how the program functions. The following example will go through creating an MVC-based application for creating and searching for users.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_006a.png)

Review the UML class diagram example. The program has one view, UserView, that uses a UserController interface and UserModel. The controller interface is implemented with SimpleController class, which defines `create()` and `get()` methods for working with users. The controller talks to the UserModel to store user information, and the view contacts the model after the state has been changed.

Now that the high-level design is represented in UML, you should be able write it all up in a programming language. MVC as an architecture pattern is not dependent on programming language or technology, of course. The components and design patterns are developed differently in different languages, but the idea stays the same. In this case, you write the program in Python, but you may take any programming language and simulate the same style of implementation. First, look at the code for the user model. The model is, as you already know, not dependent on any other component from MVC. Obviously, it can depend on libraries and other modules that help with the functionality implementation, such as database communication. In this case, the code simulates the database by storing the user data in a global variable, but it could be easily replaced by any other technology and the dependent components would not see the difference.

It is time to connect the theory with practice—first, the module component in the model.py module.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_007.png)

The responsibility of the model is to define what a desired object can have and what it can do. What a model can have, or the state of an object, is stored within the user model object. Whatever data is defined on the model usually also reflects how the data is stored in the underlying database of choice. The user model defines two properties, username and email. These two values are set on object creation, initiated from the controller, which gets the values from the input that the user enters to the view component. There are a couple of static methods, `get_user()` and `get_users()`. The first method requires an `id` argument that is used for searching for the user entry. The second simply returns the entire database of users. A third method, `store_user`, which is not static because it is referencing the current object instance through the "self" object, is used for storing new users, and it calculates a new ID for each entry request it receives. How to store new users depends on the database type. The model is responsible for storing it correctly; the dependent components use the model API.

> **Note**\
> A static method in programming is a class method that is a part of a class but not related to a class instance directly, and can be called without object creation.

Next, look at the code for the view component inside the view.py module.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_008.png)

The view component in this program implementation is responsible for taking the user input and printing the results. It is, by definition, dependent on the model, but until you come to the point of implementing the observer, it is just a light dependency because of the module import. The view in this case is very simple. It is a CLI display application that takes the user input for the username and email and sends that to the controller for further processing. It also implements a display procedure for showing a user with a specific identification number in the database.

The two methods that communicate with the controller are loosely coupled. Instead of sending an object that the controller would need to know how to interpret, they simply send the input in a string format. The `update_display()` method is used for updating the view and represents the connection from the controller to the view. When a controller performs an action that the user requested from the view, it calls back the view to update the presentation accordingly. In the case of the UserView, it prints to the standard output whether the action was successful and a message for the user.

> **Note**\
> The `update_display()` method is more tightly coupled because it deserializes a user object. It would be better in terms of design principles to make it less dependent on the user object. You can do this reimplementation.

In this example, the view is a CLI, which is not something that modern applications would use as the view. As already discussed, the idea behind MVC is that the components can be individually developed and reused as one would like. Once the CLI application works as desired, it should be trivial to replace the view component with another one that implements the presentation in desktop form or a web page. As long as the communication interfaces between the components stay the same, you can switch between different views or use multiple views simultaneously.

The last piece of the puzzle is the controller component located in the controller.py module.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_009.png) 

The first class in the module, the UserController class, is an abstraction interface and serves as a contract between the view and the implementors of the controller. There could be many different controllers for the view component, but they all need to follow the UserController abstraction blueprint and implement the methods. In this example, the controller will have two methods—one for creating a user and another serving the view functionality of displaying a user by ID number.

The continuation of the previous code from the controller.py module is the SimpleController class.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_010a.png)

This is the implementation of the strategy design pattern, where SimpleController is one of the strategies of the UserController interface. It implements the contract between them and the parent UserController class. The `create()` method implementation is reviewing the user input and preventing the user creation if the input is faulty. This is just a simple showcase of how a controller can be used as a mediator between the view and the model components. If the input was accepted, the data gets translated into a user object, and the not static method `store_user()` is called on that object. This starts the process of saving a user, which is implemented in the user model. If everything went right, the controller must update the view component that the request went through. Because the controller already has a reference to a view object, the code simply calls the `update_display()` method with the right values.

The `get()` method relies on the model component static method `get_user()` to retrieve the user from the database. The `get()` method does not need to know implementation details, nor what is the storage technology. It just requests the user by the ID and expects to get a positive or negative result based on the data in the database. What is also useful in this controller is the ability to change the output messages without having to alter the view code. Every method on the controller can prepare the correct response for the view to display. With multiple views, your code does not need to duplicate these messages across the views. If they are using the same controller, they will receive identical replies.

Now that you have the code that is written in MVC ready, you need something that will tie everything together and run the program. You could write another module—for example, app.py, in which you would import the view.py module and call the create_user() method with your set of values. You can call the method multiple times, and it should result in creating multiple users. Then, you could continue interacting with the view and call the get_user() method with an ID to retrieve the user information. You could also use the Python interactive shell and do the same interactively. The last option is showcased on the following figure.

![alt text](/DevNet/DEVASC/Images/DEVASC_1-0-0_MVC_Architecture_Pattern_011a.png)

Now you see that the program works. It would be possible to do the same in just one module, and much simpler, but that was not the point. Once you start development on bigger projects, where there are more views, controllers, models, and other moving parts in your program, you need to have a structure in your code; otherwise, you will lack the reusability, modifiability, and extensibility aspects of your application. Using an architectural pattern like MVC, you can achieve all that and avoid tangled code that is hard to maintain.

## MVC Frameworks

Having access to patterns like MVC can be very useful in various projects. For example, suppose you wrote a Python application last month with a well-structured design that separates the database communication, view, controller, and model into different folders. In that case, you might want to reuse this structure in future projects. You also created a place to store additional libraries and found an efficient way to include them in your code. This project structure makes sense and works well for the projects you are working on, and you feel comfortable reusing it. In other words, you have created your framework.

Many pre-existing frameworks offer generic functionality and can be tailored to your needs. They provide a defined way of working and promise benefits such as efficiency, stable design, loosely coupled code, and more. Many frameworks are based on the MVC pattern. You may have already used some of these frameworks without realizing it, as they encourage you to write highly reusable and flexible code. While a framework won't prevent you from writing suboptimal code in the parts where you need to add your logic, its structure should help reduce such problems. However, learning a new framework takes time and effort, but they are usually well-documented.

Finally, it's important to note that there are MVC frameworks written in different programming languages, with the first being Smalltalk-80, created in the 1980s. Here is a list of modern frameworks that enable the MVC pattern:
 - ASP.NET MVC
 - Django, Pyramid, web2py
 - Symfony, Laravel, Zend Framework
 - AngularJS, Ember.js, Wakanda
 - Spring

