
# REST-Style APIs

REST-style APIs are a subset of web API architecture styles in which the endpoints represent resources. When a REST API is called, the server transfers a representation of the state of the resource to the client. Note that REST is not a protocol.

This style was created with the HTTP standard in mind and uses the HTTP methods as its set operations, such as GET, PUT, DELETE, and so on. However, the message format syntax is not as strictly defined as with some other types (RPC), and so the message can be serialized in many different formats. JSON is the most commonly used.

REST is optimized for use on the web. It is known for excellent performance and scalability if implemented correctly. Coupled with greater simplicity than the other styles, it is no wonder that it has become the go-to API style on the web.

Play Video
Open Transcript

### REST Overview

In order for a web API to be RESTful, it has to adhere to the following architectural constraints:

 - **Client/server architecture:** The primary principle behind a client/server  - architecture is the separation of concerns, which allows both components  - to evolve independently of each other as long as the interface between  - them is not altered. It is considered a standard practice today.
 - **Statelessness:** No client context needs to be stored on the server in  - between requests for the communication to work. Each request from any  - client holds all the necessary information to service the request. If  - the session state is needed, it is stored in the client and transferred  - to the server when the client creates a new request.
 - **Cacheability:** Some HTTP responses on the web can be cached by the client  - or an intermediary agent. For a REST API to support cacheability, all  - the responses have to define themselves as cacheable or not.  - Well-managed caching can eliminate some client-server interactions such  - as improving performance. However, caching incorrect responses can cause  - stale or incorrect data to be received.
 - **Layered system:** A client should not be able to tell whether it is connected directly to an end server or to an intermediary agent along the way. The intermediary agents can, for example, be a proxy, caching server, or a load balancer. It improves scalability and allows an extra layer of security to be added.
 - **Uniform interface:** Uniform interface decouples the client from the implementation of the REST service. Individual resources are identified in the URI of the request, and the client does not need to know how the resources are represented internally on the server. When a client holds a representation of the resource returned by the server, it should have enough information to modify this resource. Server messages should be self-descriptive; therefore, they should contain enough information for the client to be able to process them. The API should also conform to Hypermedia as the Engine of Application State (HATEOAS). The client using the REST API should be able to use server-provided links dynamically to discover all the available resources and actions it needs.
 - **Code on demand (optional):** Servers should be able to temporarily extend or customize the functionality of a client by transferring some code to them. An example of extending functionalities would be running Java applets of JavaScript scripts.

### HTTP and REST

![alt text](/DevNet/DEVASC/Images/image-30.png)

RESTful APIs leverage HTTP to define the operations on the resources. While the actual operations on resources can vary a bit depending on the context and implementation, you cannot expect to use HTTP DELETE requests to create resources and call the API RESTful.

The example made-up API is defined by the following parameters:

- A URI that defines the resources—www.example.com/api/users
- A standard set of HTTP methods—GET, POST, PUT, PATCH, DELETE
- Representations of the resource defined by the media type

The following table shows a typical use of HTTP methods on two different resource types. As you can see, using different methods produces different results, and all the actions are executed on a resource. Where an RPC-style API would call a RPC "/getAllUsers," a REST-style API creates a GET request on the "Users" resource.

HTTP Method |  Collection Resource: /users | Member Resource: /users/bob
| - | - | - |
GET | Retrieves the URIs of all User members. | Retrieves a representation of the user "Bob".
POST | Creates User members with the data sent in the request body. |  Creates a user "Bob" and returns its representation.
PUT | Replaces all User members with those in the request body. Should also create the collection if it does not exist. | Replaces the user "Bob" with a representation in the request body.
PATCH | Updates all the representations of the User members with instructions from the request body. | Updates the user "Bob" with request data or creates the user if it does not exist yet.
DELETE | Deletes all the User members. | Deletes the user "Bob."

Many APIs only support read-only operations (GET) on collection resources and only allow modification through member resources.

The POST method can also be used for non-CRUD requests on functional resources. For example, an HTTP POST call on API endpoint /users/bob/logout might be used to log out the user from all their active sessions.

### REST Example

Basic HTTP request creation and response parsing are pretty straightforward in most programming languages. In this example, you can see how to use Python and its requests library to create a simple HTTP GET request to a member resource—a user with an ID of 1(/users/1)—and print the response contents.

The response content is returned as plaintext, so you have to deserialize the string into an object with the JSON library.

![alt text](/DevNet/DEVASC/Images/image-31.png)

> **Note** \
Python version >= 3.6 is required for string formatting that uses f-strings. You can find out more at https://www.python.org/dev/peps/pep-0498.

In the following example, you can see that the resource in the URI is a collection resource, a set of all the users—/users. In this case, the result is an array of objects.

![alt text](/DevNet/DEVASC/Images/image-32.png)

### REST vs. SOAP

Both REST and SOAP APIs are considered the most widely used in the world of web services today and no approach is inherently better than the other. It all depends on the problem you are trying to solve and the resources you have available.

No API style is inherently better than the others. It all depends on the problem you are trying to solve.

| | REST | SOAP |
| - | - | - |
Advantages | Better scalability, performance and flexibility | Higher security and standardization
Disadvantages | Less secure and not suitable for distributed environments | Increased complexity and poorer performance
Message format| Any | XML only
Transfer protocol | HTTP | Many; depends on the protocol
Approach | Data-driven (data as a resource) | Function-driven (data as a function call)
