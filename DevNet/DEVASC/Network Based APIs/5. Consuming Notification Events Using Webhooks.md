
# Consuming Notification Events Using Webhooks

APIs are a great tool to use if you want to get some data across the Internet exactly when you want it. But, if your only interest is in the changes of this data, APIs become quite impractical. An asynchronous method of data retrieval is needed in that instance.

Web content is becoming less static; more and more things that we do on the Internet can be described as events. Regular API calls are not very effective at tracking events and changes. Each API call only retrieves the data from the server, and then it is up to the client to determine the state or changes that happened.

The more frequent those API calls are, the more up-to-date data you have. This is semipractical when there a lot of events and changes, but not so much otherwise.

![alt text](/DevNet/DEVASC/Images/image-50.png)

Creating periodic API calls for the same set of data is called polling and is in general very wasteful. Because constant polling can use up server resources and a sizeable chunk of bandwidth, a more practical solution is needed. This is where webhooks come in.

Webhooks are tools that allow you to react to events and changes in an application. They are commonly referred to as a `reverse API` or a `web callback`. While regular APIs feature a synchronous request and response cycle, webhooks use the server to asynchronously notify the client about the changes. The client is notified only when an event happens, which means that the total amount of requests is greatly reduced, and the client is notified as close to real time as possible.

The comparison of webhooks and polling is similar to the push-pull terminology. Webhooks are analogous to the push effect (because they `push` new information to another entity), and the polling stands for the pull effect (because they `pull` the information to themselves). Webhooks are therefore a push version of an API.

![alt text](/DevNet/DEVASC/Images/image-51.png)

## So how do webhooks work?

They work in reverse from regular APIs and invert the server/client concept. Instead of the client creating a request toward the server, a client subscribes to a specific webhook. This is done by creating a POST request to the webhook endpoint. The POST request usually contains more data, such as authentication data, which events the client wants to subscribe to, which address and port should be notified, and other data. This puts the client on a list of subscribers for particular events. When those events happen on the server, another POST request is used to notify the client and provide them with event data. This is called a webhook notification and it needs to be caught by the client. These notifications can contain the data of the event or just a reference to this data, which can then be read over a regular API.

Consuming a webhook requires detailed knowledge of the API. In contrast to polling the API, where similar to pressing the reload button, each poll has a reaction (even if it is an error), webhooks only become active when they have to. Some webhooks will pay attention to the client response and will retry sending the data, while others will make a request, then forget about the data. This is why it is important to thoroughly test and debug the webhook, using tools like Hookbin or ngrok.

As with APIs, webhooks present another attack target for potential attackers. Security, authentication, and authorization mechanisms are the same as with regular APIs; use HTTPS for encryption, use different access levels for different events, delegate credentials to users via a secure channel, and so on.

In the real world, you would commonly subscribe to a public webhook from a secure enterprise network that features a firewall, which blocks most of the incoming requests. Therefore, your machine usually is not accessible from the public web. To get around exposing your machine to the world, a common practice is to use webhook forwarding services or reverse HTTP proxies that securely deliver the webhook notifications to the clients.

Take a look at a simple example of how webhooks can be used to integrate different products. Imagine that you are a software developer in charge of integration between Cisco Webex Teams and a ticketing system. Your company uses Webex Teams for internal communication as well as for communication with customers. The support department uses a dedicated room for reporting errors, because the customers do not have access to a ticketing system. Each time a new message gets posted into that room, a new ticket needs to be automatically opened in the ticketing system.

Webhooks are used in many areas:

- Marketing (newsletters, advertisement distribution)
- Monitoring (listen for alarms and errors on other systems)
- Social networks (notifications)
- Many other event-driven services

![alt text](/DevNet/DEVASC/Images/image-52.png)

Cisco Webex Teams features a clean and useful API, so the integration will be done over it. You could implement this integration by creating an agent that sequentially polls the API, compares the current room content with the previous, and figures out if there were any new messages. Webex Teams also features webhooks in its API.

First, you need to subscribe to a webhook. With Webex Teams, this is easy enough:

1. Authenticate your request, just as you would when consuming the API.
2. Pick a name for your webhook subscription.
3. Set the target URL. This URL (or IP address) will be notified when the webhook triggers.
4. Select the subscription resource. This, together with the event parameter, determines about which events you will be notified.
5. Add filters. In this case, you only care about messages, posted in a specific room, so you add a room filter.

![alt text](/DevNet/DEVASC/Images/image-53.png)

Because Webex Teams uses a REST API, a POST request modifies a resource. A GET request on the same endpoint should return a list of all your subscribed webhooks.

The second step is catching the notifications, which can be done by a simple listening agent or as a part of the ticketing system. You can also find many ready-to-go containers and other products on the Internet that feature webhook listeners (for example, the Python Flask framework or JavaScript Node.js framework).

With the listening agent set up, you can now listen to incoming webhook notifications.

The following figure illustrates how a notification from the previously mentioned Webex Teams support room would look like.

Note the following elements of the POST request:

The text itself from the chat has not been added to the HTTP request. To get the message that has been posted, an additional GET request has to be made to get the content by its ID.

If you needed to find out more about the person opening the ticket, you could create a GET request for the person with the same person ID.

![alt text](/DevNet/DEVASC/Images/image-54.png)

After the notification has been caught and parsed, a new ticket can be opened with this data, and thus, the two products integrated.
