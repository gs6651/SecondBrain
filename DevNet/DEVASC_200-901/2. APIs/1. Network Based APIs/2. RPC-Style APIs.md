
# RPC-Style APIs

Over time, several different API types have evolved to suit different needs and to solve different types of problems. The two most commonly used API types are remote procedure call (RPC) API and REST API. In programming, usually more than one approach to a problem is valid, which is also true for building APIs. But it is useful to know the strengths and weaknesses of different approaches so that you can pick the best implementation depending on the job. Here, RPC-style APIs will be introduced.

### What Is an RPC-Style API?

![alt text](/DevNet/DEVASC_200-901/Images/image-20.png)

RPC APIs are exactly what their name stands for. RPC APIs "call" a remote procedure located in a different address space similarly as to how it would call a procedure locally. A different address space can either be on a different computer or in a different network.

The client sends a call to the server, usually with some parameters, and then waits for the server to return a reply message. Once the reply message is received, the results of the procedure are extracted and the client execution is resumed. There are no limitations on concurrency, so RPC calls can also be executed asynchronously.

Each RPC-style endpoint thus represents a remote function call.

Because the procedures are executed remotely, you have to take into account the following:

 - Error handling is a bit different than local error handling. All  - procedure errors should be handled on the remote server, and a  - corresponding error should be sent to the client.
 - Global variables and side effects on the remote server are sometimes  - unknown or hidden to a client, because it has no access to the server  - address space.
 - The performance of remote procedures is worse than the performance of  - local procedures. In addition to procedure execution, the client and the  - server have to take care of overhead, which is caused by the transport.
 - Authentication may be necessary, because remote procedure calls sometimes are transported over insecure networks.

Because RPC API is only a style of building an API, many different protocols have evolved that implement remote procedure calls.

### Simple Object Access Protocol
Simple Object Access Protocol (SOAP) is considered an underlying layer of some of the more complex web services based on Web Services Description Language (WSDL), an interface for describing the functionalities offered by web services, which makes discovery and integration with a remote web service very straightforward.

In addition to a more strictly defined syntax, it has three main characteristics:

 - **Extensibility:** Features can be added without major updates to the  - implementation. Security (WS-Security or WSS) and WS-Addressing can be  - added to SOAP.
 - **Neutrality:** SOAP is not protocol specific and is able to operate over  - several different transport protocols, such as HTTP, TCP, Simple Mail  - Transfer Protocol (SMTP), and so on.
 - **Independence:** It supports any programming model (object-oriented, functional, imperative, and so on), platform, and language.

The SOAP specification defines the messaging framework, which consists of four parts.

Element | Description | Required
| - | - | - |
Envelope | Identifies the XML document as a SOAP message. | Yes
Header | Contains SOAP header information. | No
Body | Body of the message; contains the remote call, parameters, and response information. | Yes
Fault | Provides information about any errors that occurred. | No

Examples of a SOAP request and the corresponding response:

```html
POST /customers HTTP/1.1
Host: www.example.com
Content-Type: application/soap+xml; charset = utf-8
SOAPAction: "http://www.w3.org/2003/05/soapenvelope"
 
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soapenvelope" xmlns:m="http://www.example.org">
  <soap:Header>
  </soap:Header>
  <soap:Body xmlns:m ="http://www.example.org">
    <m:GetCustomer>
      <m:CustomerName>Joe</m:CustomerName>
    </m:GetCustomer >
  </soap:Body>
</soap:Envelope>
```
```html
HTTP/1.1 200 OK
Content-Type: application/soap+xml; charset = utf-8
Content-Length: 256

<?xml version = "1.0"?>
<soap:Envelope
   xmlns:soap = "http://www.w3.org/2001/12/soapenvelope"
   soap:encodingStyle = "http://www.w3.org/2001/12/soap-encoding">
   <soap:Body xmlns:m = "http://www.example.org">
      <m:GetCustomerResponse>
         <m:Customer>
             <m:CustomerId>173</m:CustomerId>
             <m:CustomerName>Joe</m:CustomerName>
            <m:CustomerLocation>London</m:CustomerLocation>
         </m:Customer>
      </m:GetCustomerResponse>
   </soap:Body>
</soap:Envelope>
```

### JSON-RPC

JSON-RPC is a very simple and lightweight RPC protocol encoded in JSON that defines only a few primitive data types, such as string, integer, Boolean, and null, and commands such as `params`, `method`, `id`, and so on.

It also supports notifications like sending data to the server that does not require a response, which is useful for asynchronous updates and batch requests (multiple requests inside one request body).

![alt text](/DevNet/DEVASC_200-901/Images/image-21.png)

### XML-RPC

XML-RPC is a protocol that is similar to SOAP. However, it is less structured and uses fewer constraints than SOAP. In addition to the basic data types, it also supports some more complex types like Base64, array, datetime, and struct.

It also supports basic HTTP authentication.

![alt text](/DevNet/DEVASC_200-901/Images/image-22.png)


### Network Configuration Protocol

Network Configuration Protocol (NETCONF) is a network device configuration management protocol that provides mechanisms to install, manipulate, and delete configurations on network devices. It also provides a mechanism for notification subscriptions and asynchronous message delivery.

NETCONF consists of four layers:

 - **Content layer:** Contains the actual configuration and notification data.
 - **Operations layer:** Defines a set of base protocol operations to retrieve  - and edit the configuration data. Basic operations are <get-config>,  - <edit-config>, <lock>, <create-subscription>, <kill-session>, and  - similar.
 - **Message layer:** Provides a mechanism for encoding remote procedure calls.  - They are encoded in RPC invocations (<rpc> message), replies  - (<rpc-reply>), and notifications (<notification>).
 - **Secure transport layer:** Ensures a secure and reliable transport between a client and a server.

The communication between a client and the server is session-based. The server and client explicitly establish a connection and a session before exchanging data (using XML for encapsulation), and close the session and connection when they are finished. NETCONF servers are usually network devices like routers, switches, and so on.

NETCONF uses session-based communication.

![alt text](/DevNet/DEVASC_200-901/Images/image-23.png)

The basic structure of a NETCONF session is as follows:

1. The client application establishes a connection to the NETCONF server and opens a session.
2. Both the server and the client exchange some information, which is used to determine compatibility and to inform each other about their capabilities. These represent a set of functionalities that supplement the base NETCONF specifications.

![alt text](/DevNet/DEVASC_200-901/Images/image-24.png)

3. The client then sends one or more requests to the NETCONF server and parses its responses.

![alt text](/DevNet/DEVASC_200-901/Images/image-25.png)

4. The client application closes the NETCONF session and the connection to the server.

![alt text](/DevNet/DEVASC_200-901/Images/image-26.png)

### gRPC

With ever-increasing popularity and reliance on web API, the open source protocol gRPC was developed by Google.

It is built with performance in mind on top of HTTP/2, which is a protocol designed to overcome many of the faults in HTTP/1.1. The main difference between HTTP/1.1 and HTTP/2 is that the latter supports request multiplexing over a single TCP connection and is in binary.

A special format is used for data serialization, called Protocol Buffers. This format defines the structure of the message, which is then serialized to a binary output stream.

An example is shown here. Note that values 1, 2, and 3 do not represent the actual values, but keys as to where in the message stream the values reside.

![alt text](/DevNet/DEVASC_200-901/Images/image-27.png)
