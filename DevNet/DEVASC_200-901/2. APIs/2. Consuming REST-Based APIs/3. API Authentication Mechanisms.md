
# API Authentication Mechanisms

API endpoints are regularly exposed to the public Internet in one way or another, so they are not something that should be left unchecked for the public to use. Not only do you have to prevent sensitive data being exposed to unauthorized users, APIs are also commonly a target for other types of attacks. Therefore, it is imperative that only authenticated users have access and permission to use them. Several authentication mechanisms are in use today.

Before talking about different API authentication mechanisms, a distinction has to be made between authentication and authorization, because the two terms often get mixed up or used interchangeably. Many API platforms also offer authentication and authorization as a combined existing feature, so the line between the terms is sometimes thin.

Authentication is the act of proving the identity of someone. Each identity is a unique combination of properties (names, IDs, and so on) that in turn represents a unique entityâ€”a person, user, product, and more.

![alt text](/DevNet/DEVASC_200-901/Images/image-320.png)

Authorization, on the other hand, specifies the rights and privileges that a specific entity has over resources; it defines the access policy for an entity.

![alt text](/DevNet/DEVASC_200-901/Images/image-321.png)

Take a look at a driver license, which is an example of both authentication and authorization. It authenticates you as a person and authorizes you to operate certain vehicles. In the context of the information technology, authentication makes sure that you are who you say you are, and authorization makes sure that you have the right to the data that you are trying to access.

Communication between the API consumer and the API server happens with the exchange of HTTP requests and responses, so it makes sense for authentication to use some of the existing HTTP mechanism.

Today, most of the REST APIs use HTTP headers to store various authentication data.

While the implementations may vary, three general approaches exist:

- **Basic HTTP authentication:** Uses built-in HTTP authentication.
- **API key authentication:** Client adds a pregenerated key to HTTP headers.
- **Custom token authentication:** A dynamically generated token is used.

Sometimes, publicly available APIs require no authentication (for example, weather data, government registries, and other data available to the public), but they are usually rate limited by network address or aggregated client information.

API key authentication uses a unique, pregenerated, cryptographically strong string as the authentication key, which is encoded in Base64 encoding schema, so it can be transported using HTTP.

Clients encode the key either in the HTTP request headers as a cookie or as an individual header, or as a URL parameter. When the API request arrives at the server, the key is first parsed from the request, decoded from Base64, and compared to a database table, containing valid keys.

These authentication keys are generated on the server on demand by the API administrator. A common practice is to generate the keys on a per-user or per-service basis. It means that you should avoid using a single key that has authorization for every possible API action and using it for everything. The scope of the keys should be limited to their intended use.

API keys are usually only given to the users at the time of their creation for security reasons. If a user has to figure out which key does what later, they can still identify the keys by their prefixes; for example, only the first five characters of the key are displayed, which mostly eliminates duplicates but still guarantees uniqueness. If the key gets lost, a new one can easily be generated. This authentication method is not as safe as it could be. Because the authentication key is an immutable string that stays the same until it is deleted from the server, it can be intercepted by an attacker and used to create API calls in the name of the user for whom the key was generated.

The following example shows how the generated keys look on a Cisco Meraki platform and how the said keys would be used as an URL parameter or as an HTTP cookie. Using the URL parameter to send an API key is not a good practice, though, because the key can get exposed much more easily.

![alt text](/DevNet/DEVASC_200-901/Images/image-322.png)

Here is another example of how you would actually create a new user, using API key authentication, implemented in Python with the help of the Python Requests library.

Note how the API key is added to the request as an HTTP header.

![alt text](/DevNet/DEVASC_200-901/Images/image-323.png)

In case the API key is invalid or not valid anymore, a 401 Unauthorized HTTP error will notify you. If the key is valid but just not authorized for the resource you are trying to access, a 403 Forbidden error should appear. Because the implementation of error codes is mostly up to the developer, you might encounter more generic HTTP codes for such errors with some APIs (for example, just returning a code 400 or even 200 and then appending a message such as "Authentication unsuccessful" as the response body).

The problem with both the basic HTTP authentication and API key authentication is that the authentication details have to be sent (and therefore processed and compared) with every API call. This action creates a weak point in security, because every request contains this data and is thus a viable attack surface.

Custom token (or access token) authentication solves this problem by using a custom token instead of this authentication data. In addition, the token is then commonly used for authorization, too.

The process of authentication is as follows:

1. The client tries to access the application.
2. Because the client is not authenticated, it redirects it to an authentication server, where the user provides the username and password.
3. The authentication server validates the credentials. If they are valid, a custom, time-limited, and signed authentication token is issued and returned to the user.
4. The client request now contains the custom token, so the authenticated request is passed to the API service.
5. The API service validates the token and serves the required data.

![alt text](/DevNet/DEVASC_200-901/Images/image-324.png)

The authentication server is often an external service (for example, OpenID) that is used in combination with an authorization mechanism (for example, OAuth 2.0). The tokens themselves often contain some authorization data as well. Authentication servers are commonly used to issue tokens that can be used with many different services from different vendors (for example, using Google authentication to log in to an unrelated site that has implemented Google sign-in).

The term that is commonly used for this type of authentication (and authorization) is single sign-on (SSO). SSO is gaining in popularity, because it is very useful for services that require third-party authorization (for example, sharing an article from a news site on a social media account) or for businesses that offer several different services but want users to use the same identity for all of them (for example, Google Apps, your company enterprise environment, and so on).

The pros of custom token authentication include:

- **Faster response times:** Only the token (and maybe its session) has to be validated instead of the credentials. Sessions are often kept in very fast in-memory databases (for example, Redis), while credentials are kept in nonvolatile memory relational databases.
- **Simplicity of cross-service use:** This reduces the number of the authentication systems needed in an organization and unifies authentication and authorization policies across the services.
- **Increased security:** The credentials are not passed with every request, but rather only once in the beginning and periodically after that when the token expires. This way, it reduces the chance of success and viable time frame for any man-in-the-middle or cross-site attacks.

While offering a step forward in most areas of authentication, custom token authentication is a bit more complex than the other types. There is also less granular control over individual tokens, because in case the private key of the authentication server gets compromised, all the tokens must be invalidated.
