
# Using HTTP Authentication

HTTP provides a framework for basic authentication and access control, which is often a good enough solution for simple APIs.

To understand how you can use the HTTP authentication in your API, it is important to know how HTTP authentication actually works. When an unauthenticated (and consequently unauthorized) client makes a request toward the HTTP server, the server in turn challenges the received HTTP request. The challenge is done by using an error code (401 Unauthorized) and the WWW-Authenticate HTTP header in the response. This header defines which authentication method should be used to gain access to the resource specified in the request, because several methods exist.

The client must then send another request, this time using the Authorization header, which contains the authentication type and the authentication credentials. The realm is a string that denotes some protected space on the server to which only authorized users have access; think of the realm as a group of resources, a specific server, and so on.

If the credentials within the request Authorization header are valid, the server responds with a 200 OK HTTP response (or 403 Forbidden if the opposite occurs).

The following UML sequence diagram depicts the exchange of HTTP messages between the client and the server.

![alt text](/DevNet/DEVASC_200-901/Images/image-340.png)

HTTP authentication uses several different authentication schemes:

- Anonymous (no authentication)
- Basic (Base64-encoded credentials as username:password)
- Bearer (HTTP implementation of custom token authentication)
- Digest (MD5-hashed credentials)
- Mutual (two-way authentication)
- More uncommon schemes (HMAC, HOBA, AWS, OAuth, Negotiate, and so on)

It is important to note that no HTTP authentication schema is secure by itself. At the very least, Transport Layer Security (TLS) should be used to encrypt the connection (forming an HTTPS connection).

Some schemas are inherently less secure than others. For example, the Basic schema uses Base64 to encode credentials, but because Base64 is just an encoding, not an encryption; the username and password can easily be decoded. Hashed credentials are more secure because the credentials are never sent in a clear or encoded form but follow a hashing algorithm, which can be a big obstacle for any potential attackers.

The following figure is a Python-based example of basic HTTP authentication, using the requests and Base64 modules. Note how the credentials are encoded before the Authorization header is put together.

![alt text](/DevNet/DEVASC_200-901/Images/image-341.png)

Basic HTTP authentication parameters can also be sent via the URL. The format looks like the following: http://username:password@www.example.com/users. However, this method can get rejected by some APIs because it is rarely used.

In the real world, it is common to see the use of proxies for the role of access control, which is why HTTP authentication includes specific headers to deal with proxy authentication.

Instead of the WWW-Authenticate header, the Proxy-Authenticate header (with corresponding error code 407 Proxy Authentication Required) is used, and instead of the Authorization header, the Proxy-Authorization header is used. Both proxy headers are single hop only and can be combined in a single message with the regular WWW-Authenticate and Authorization headers (which are end to end).

Proxies, however, do not work well if many of them are chained in front of an API. HTTP tunneling must instead be used.

The following UML sequence diagram depicts the exchange of HTTP messages between the client and the server with a proxy in between.

![alt text](/DevNet/DEVASC_200-901/Images/image-342.png)
