
# Leveraging HTTPS for Security

HTTP has never been considered a trusted connection. Even if the content transported by HTTP requires no authorization, an attacker with access to the network can still intercept and modify any HTTP messages that pass through it. This reason is why HTTPS should be used in its place for everything you do on the Internet.

HTTPS is an extension of HTTP that encrypts the communication between the client and the server.

The primary motivation for the emergence of HTTPS was the lack of privacy when communicating over HTTP. Before HTTPS, the messages could be intercepted, decoded, forged, dropped, and manipulated in several other ways. Since its inception, it has been used for secure payments, emails, and sensitive transactions. Widespread use started a bit later; the added encryption and decryption was too CPU-intensive for everyday use. In 2018, however, it overtook HTTP as the most common way of transporting data across the Internet. Most browsers now actually notify you if you are using a website without a certificate installed.

For encryption, TLS is used. TLS has replaced the older and deprecated Secure Sockets Layer (SSL). TLS ensures a reliable, private, and secure connection using public key cryptography. It uses a security mechanism called digital certificates.

HTTPS and certificates also are used to ensure the identity of the accessed website or API. While HTTPS needs to establish an SSL/TLS session to begin the communication, it is still considered a stateless protocol. Port 443 is used for communication by default (while HTTP uses port 80).

HTTPS uses public key cryptography, an encryption and decryption technique that uses key pairs and requires public and private keys, which are not the same but are loosely mathematically related. Keys are strings of numbers and letters. A public key is publicly known and is used to encrypt messages that can then be decrypted only by the private key of the receiver. This is called asymmetric cryptography. If both parties possessed a key that could encrypt and decrypt the message, it would be called symmetric cryptography.

A suitable analogy for public key encryption is that of a box with two keys. One key (public key) can only close the lock, while the other (private) can only open it. If someone with a public key puts something in that box and then locks it, only the person with the private key can then open it and retrieve the contents. You cannot be sure who put something in the box, because it has been locked with a key that is publicly known, and you can be sure that nobody else other than you can open the box and access the content, because only your key can open the lock on the box once it has been closed.

![alt text](/DevNet/DEVASC_200-901/Images/image-350.png)

One of the most commonly used encryption algorithms is called Rivest, Shamir, and Adleman (RSA) and is based on the idea that it is very difficult to factorize a large number. The public key consists of two large prime numbers, and the private key is also derived from them. If someone could factorize the large number, the private key would become compromised. While the private key in asymmetric cryptography can be brute-forced, the time frames required for modern (2048-plus-bit) keys are often in thousands of millions of years because of sheer size and the number of possibilities.

Digital certificates provide identity for a digital entity. They are similar to what passports are for people and certify that a public key really belongs to a specified entity. That is why they are also sometimes called public key certificates. If the public keys were exchanged before encrypting the actual connection, a risk would exist that the keys would be intercepted or replaced, and the consequential communication would not be secure. To solve this problem, public keys are exchanged through a trusted third party and incorporated into these certificates. These trusted third parties are called certificate authorities (CAs).

CAs are trusted businesses that specialize in issuing digital certificates. The CA business is fragmented worldwide, with many local, national, and regional providers having sizeable shares of issued certificates, due to local regulatory standards. Having thousands of authorities you should trust is not practical, so globally trusted CAs exist (Comodo, IdenTrust, GoDaddy, Let's Encrypt, and so on) that are much smaller in number because of much stricter validation standards.

The trust for local CAs is inferred through the chain of trust (certificate chain), which contains multiple certificates that sign the one above it. For example, when you add a certificate to your website, you can buy it from a local CA, who then signs your web page certificate. Your certificate is an end-entity certificate. Because the local CA also needs their certificate signed, they get it done by a national CA. A national CA has their certificates signed by a larger entity, such as an international CA. These certificates are called intermediary certificates. And finally, these CAs have their certificates signed by a trusted root CA. These are added by default in most browsers and operating systems and are called root certificates.

The following figure depicts a certificate chain for the Cisco home page as viewed in Mozilla Firefox Certificate Viewer.

![alt text](/DevNet/DEVASC_200-901/Images/image-351.png)

Certificates contain predefined information that is defined in the X.509 standard and includes:

- Public key of owner
- Distinguished name (DN) of owner
- DN of CA
- Valid from and expiry dates
- Unique serial number of certificate
- Protocol information

Depending on the scope, digital certificates can be further classified as one of the three types:

- **Single domain:** Applies to one hostname only (such as `www.example.com`).
- **Wildcard:** Applies to an entire domain and its subdomains (example.com will include domains like mail.example.com and admin.example.com).
- **Multidomain:** Applies to several different domains (either single domain or wildcard).

When a client and a server want to begin the encrypted connection, either for browsing or consuming an API, it is done via a series of messages, which is called a TLS handshake.

![alt text](/DevNet/DEVASC_200-901/Images/image-352.png)

Note that the different encryption algorithms will generate keys differently. The previous example is valid for RSA-based encryption. Some other encryption types avoid using private keys for handshake; keyless SSL (for example, Diffie-Hellman encryption) is useful for cloud-hosted services with high privacy standards.

Even though HTTPS is considered secure, several attacks still exist on HTTPS itself, the TLS handshake, or the digital certificates.

Almost every attacker using this attack surface tries to achieve the man-in-the-middle (MITM) attack, where a malicious user intercepts, listens to, and modifies the communication between two entities. While HTTPS encryption counters the most basic MITM attacks, where the attacker simply intercepts and reads unencrypted messages, more advanced versions of the attack are still possible:

- **HTTPS spoofing:** Can be used to send fake certificates to the client, thus making the client trust your connection as the real one.
- **SSL hijacking:** Describes copying fake authentication keys to the client and server, having full access to the communication channel.
- **SSL Stripping:** Tries to convert the HTTPS connection to a regular HTTP by interrupting the TLS handshake and exploiting redirects.
- **Downgrade attacks:** Focus on abusing backward compatibility, which many protocols feature. It tries forcing the system to fall back to an older or less protected version of software in order to exploit any known vulnerabilities that they feature.
- **Exploiting software bugs:** Can have disastrous consequences, as was seen with the Heartbleed bug that exploited a vulnerability in OpenSSL library.
- **Phishing attacks:** Used to try to trick the user into accepting some fraudulent certificates as trusted (either with fake websites or fake emails).

![alt text](/DevNet/DEVASC_200-901/Images/image-353.png)

In addition to encryption, MITM can be prevented by using common sense and not opening any suspicious attachments, double-checking unexpected redirections, and making sure you only confirm and trust valid certificates during pop-ups. As far as system administration goes, it is very important to keep your systems and APIs up to date to retrieve certificates only from legitimate CAs, and use advanced certificates that feature extended validation, because they are considered more trustworthy.