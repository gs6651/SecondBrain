
# Handling Secrets for API Consumption

Imagine an API call as a transfer of a physical bag of money from one bank to another. You can hire an extremely reliable security company for transport (HTTPS) and use an incredibly resilient safe to store the money (for example, high-security data center) to stay as secure as possible. However, both measures will prove ineffective if you leave the keys by your main door and use the same keys for the maintenance room as you do for the main safe, or if the security guards debate their detailed schedule at a local bar.

This analogy should give you an idea that a security vulnerability is often not the one that is most obvious, but rather the one who makes the most mistakes—you.

API secrets, or in general, any kind of credentials and authentication data, is one of the most sensitive pieces of information, because it often grants you partial or full access to a system or an API. Yet, they are sometimes found written on sticky notes, in credentials.txt files, or as an admin:admin combination. These are, however, beginner mistakes when it comes to credential management, and as a software developer, you need to be aware of best practices regarding advanced credentials handling.

One of the most basic rules is avoid hardcoding. Hardcoding is the practice of embedding variable values directly into the source code. While it is tempting—and sometimes useful or even mandatory—to store the credentials directly where they are needed, it should be avoided and is considered a very bad idea for multiple reasons:

- **Loss of portability:** Hardcoded credentials only work for a specific user or API endpoint, which means your code cannot be used for multiple instances with different credentials.
- **Security vulnerability:** If the credentials are contained as a plaintext, they can be seen by anyone with access to the code repository or to the system on which said code is installed.
- **Increased time to change:** Credentials can be harder to change, because they require changes in the code. This commonly means that not only the operations department has to be involved, but the software department as well. Also, the code or the module has to be redeployed, which can result in service disruption.

Spot the error or errors in the following code snippet. What if the API key changes? What if you want to reuse the code for another API?

![alt text](/DevNet/DEVASC_200-901/Images/image-360.png)

When you include dynamic data in your code that has a possibility to change and is not a part of business logic itself, try to stick to softcoding that data. Softcoding is a technique of obtaining variable values from external resources (configuration files, preprocessor, external constants, and so on) and makes your code less domain-specific.

The following code snippet does the same as the previous snippet, with a few differences:

- The API key is read from a configuration file with the use of the configparser library. This way, it is easier to change the API key, because only a configuration file needs to be updated.
- The API URL is read from the application context. An application context is a commonly used software concept and represents the runtime configuration of the application. It usually contains data that would be different between instances (such as different names, IP addresses, different credentials, current state of components, and more).
- The result limit is still hardcoded, but only as a default value, and it can be overwritten with a function parameter.

![alt text](/DevNet/DEVASC_200-901/Images/image-361.png)

There are some specific cases where values can be hardcoded, most notably mathematical formulas and constants (for example, number Pi or a 90-degree angle), domain rules (for example, legal drinking age in a certain country), and business-specific rules.

Similarly to hardcoded credentials being a security vulnerability, incorrectly implemented logging can also give out sensitive information where it should not.

Logging should be implemented in a way that it does not give out sensitive information to unauthorized users:

- Use a true-false switch for logging sensitive information. It is usually used for applications running in different environments (for example, logging everything in a development environment but logging very little in production environments).
- Use postprocessing to mask logs. A common practice is to "catch" the default logs, read and process them, and mask sensitive information. While smart logging tools can do that by themselves, regular expressions are also commonly used to catch sensitive information (for example, mask everything after a '&password=' string).
- Have different access levels for different users. Show only the general errors and logs for regular users, and allow only administrators to see low-level logging.

Another example of where sensitive data shows up where it should not is using credentials as URL parameters. While credentials are encrypted, when using an HTTPS connection, even if they are contained in the URL (for example, a POST request on '/api?username=admin&password=Pizza123'), they can still be seen in various server logs, bookmarks, recently visited websites, and more. Credentials should always be sent as parameters inside the request body.

![alt text](/DevNet/DEVASC_200-901/Images/image-362.png)

One of the last lines of defense comes in play in case of unauthorized or unexpected access to your system—encryption at rest.

Generally, data is in one of three states—in transit, in process, or at rest. Data in transit is traveling from one place to another, usually via a computer network, and uses various protocols (HTTPS, SSH, and so on) to protect it. Data in use is active data that is either being processed or is frequently processed, and is commonly stored in computer memory. Data at rest, however, is data that is stored in a digital form on a nonvolatile physical medium (for example, a database, a spreadsheet, and so on) and poses a tempting target for any attackers. If a malicious user gains access to data at rest, only encryption will prevent them from seeing the actual data.

Encryption at rest therefore means the encoding and protection of data when it is stored somewhere.

Data is encrypted with symmetric encryption. The same encryption key encrypts and decrypts the data as it is written to storage. Different data sets use different encoding keys so that in case the encryption key gets leaked, not all data is compromised at once. Effective key management becomes important, for which dedicated cryptographic key servers with access control and auditing are used.

![alt text](/DevNet/DEVASC_200-901/Images/image-363.png)

Three different encryption methods are commonly used:

- **Full-disk encryption:** Encrypts all the data on the disk, usually with the help of the operating system. The encryption key commonly is a password that the administrator enters when disk encryption starts. Some disks even feature physical chips that are used for disk encryption (self-encrypting drives [SEDs]). Accessing any data or API credentials stored there, or even just booting up a system that is installed on that disk, requires the encryption key.
- **File system encryption:** Alternatively, only certain files, file systems, or partitions can be encrypted. In this way, only the sensitive data can be encrypted (for example, documents, credentials, and so on), while the operational data (for example, operating system, office programs) is not. Symmetric encryption is used here as well.
- **Database encryption:** Because data commonly is stored in a database, the database software often allows you to encrypt the data at the application level. Similarly to disk and file encryption, a password is needed to transparently access the data.
